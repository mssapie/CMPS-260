<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 3 Programming Assignment</title>
<style>* { font-family: monospace; }</style>
<script>

// NOTE: You must implement the data structures using the no prototype approach.
//       This is what the book uses, so you can copy it.
//       See also: https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/

// NOTE: Please review the following links regularly:
//       https://it.pointpark.edu/tutorials/arrays-vs-objects/
//       https://it.pointpark.edu/tutorials/no-prototype-vs-prototype/
//       https://it.pointpark.edu/tutorials/implementation-vs-interface/



//--------------------------------//
// The linked list data structure //
//--------------------------------//
console.log("The linked list data structure");

// 1. Suppose you have an array with 1,000 elements and a linked list with 1,000
//    elements. For both data structures, you want to retrieve the last entry.
//    Does one data structure complete that operation before the other (i.e.,
//    is it faster)? If yes, how much faster? If no, why does it take the same
//    amount of time?

// The array is much faster at finding the end of the list of information. The array only
// requires you to call array [length-1] for the last node, whereas a linked list requires you
// to traverse the whole linked list with a loop to find the node that points to "null" at which point it
// will take far longer with larger amounts of data.


//------------------------//
// Creating a linked list //
//------------------------//
console.log("Creating a linked list");

// We are going to implement the linked list data structure described in the
// book. Instead of using 'let' we use 'var' everywhere. Note that this
// implementation does not use the prototype (see homework). Here is a skeleton
// that we will work on completing:

function LinkedList() {

  // helper class
  function Node(element) {
    this.element = element;
    this.next = null;
  }

  // store length and head
  var length = 0;
  var head = null;

  this.append = function(element) {
  {
     var node = new Node(element);
     var current;

     if (head === null)
     {
       head = node;
     }
     else
     {
       current = head;

       while(current.next)
       {
         current = current.next;
       }

       current.next = node;
     }
     length++;
   };
 };

  this.insert = function(position, element) {
  {
      if (position >= 0 && position <= length)
      {
        var node = new Node(element);
        var current = head;
        var previous;
        var index = 0;

        if (position === 0)
        {
          node.next = current;
          head = node;
        }
        else
        {
          while (index++ < position)
          {
            previous = current;
            current = current.next;
          }
          node.next = current;
          previous.next = node;
        }

        length++;

      return true;
      }
      else
      {
        return false;
      }
  };

  this.removeAt = function(position) {
    if (position > -1 && position < length)
   {
     var current = head;
     var previous;
     var index = 0;


     if (position === 0)
     {
       head = current.next;
     }
     else
     {
       while (index++ < position)
       {
        previous = current;
        current = current.next;
       }
       previous.next = current.next;
     }

     length--;
     return current.element;
   }
   else
   {
     return null;
   }
  };

  this.remove = function(element) {
    var index = this.indexOf(element);
    return this.removeAt(index);
  };

  this.indexOf = function(element)
  {
    var current = head;
    var index = 0;

    while (current)
    {
      if (element === current.element)
      {
        return index;
      }
      index++;
      current = current.next;
    }

    return -1;
  };

  this.indexOf = function(element) {
    // return the index of an element in the list
    // ...
  };

  this.isEmpty = function() {
    return length === 0;
  };

  this.size = function()
  {
    return length;
  };

  this.getHead = function()
  {
    return head;
  }

  this.toString = function() {
    // overwrite the default toString method
    var current = head;
    var string = "List: ";
    while (current) {
      string += current.element + (current.next ? " -> " : "");
      current = current.next;
    }
    return string;
  };

  this.print = function() {

    console.log(this.toString());
  };

}

// create a linked list to operate on
var list = new LinkedList();

// 1. Write pseudo code (meaning; use comments) to describe how you would
//    implement the append method. HINT: What two scenarios can you distinguish?
/*
  you need to set a new node variable and a helper variable to help traverse the linked list.
  You need to check for an empty list first before appending the node.

  if(list is empty)
    new node is the head of the list
  else
    loop
      traverse list until you find the end
      set final node to link from current Node

  add to the length variable
*/

// 2. Translate your pseudo code into actual code and test it.
//    HINT: Use list.print() to test your code.
list.append("milk");
console.log("milk is " + list.indexOf("milk"));
list.append("eggs");
console.log("eggs is " + list.indexOf("eggs"));
list.append("brebs");
console.log("brebs is " + list.indexOf("brebs"));

console.log("list length is " + list.size());

list.print();



// 3. Repeat (1) and (2) for insert.

/*
start by checking for position out of bounds, then check for position = head of the list. if neither,
traverse the list to find the spot where we are inserting a node, add it from the list, link the previous node to the new node,
and end the function.

declare new Node.
declare helper variables for indexing, storing previous and current nodes.

if(position not out of bounds)
  if(position = 0)
    new head is next Node
  else
    loop while index is in range
      set previous node pointer to new node pointer
    set current pointer to previous Node
  increase the length variable
  return the dropped node
else
  return null
*/

list.insert(1,"coffee");
list.insert(2,"sugar");
list.insert(1,"oatmeal");

list.print();

// 4. Repeat (1) and (2) for removeAt.

/*
  start by checking for position out of bounds, then check for position = head of the list. if neither,
  traverse the list to find the offending node, remove it from the list, link the previous node to the next node,
  and end the function. let the garbage collector remove the unlinked Node.

  declare helper variables for indexing, storing previous and current nodes.

  if(position not out of bounds)
    if(position = 0)
      new head is next Node
    else
      loop while index is in range
        set previous node pointer to new node pointer
      set current pointer to previous Node
    decrease the length variable
    return true that a node could be added there
  else
    return false that a node could not be added there
*/
console.log("removing " + list.removeAt(2));
list.print();

// 5. Repeat (1) and (2) for remove.

/*
  Declare index variable and set it to a call of indexOf
  return the value given by calling removeAt using the index we have obtained.
*/

console.log("removing " + list.remove("eggs"));
list.print();


// 6. Repeat (1) and (2) for indexOf.

/*
  check to see if an element passed into the function is in the list. return the position of the element

  declare indexing helper and node traversal variables.

  loop traversing List
    if current element list equals element we are looking for
      return index of element
    increase index helper variable
    move along loop with new node

  return -1 indicating that we did not find the element in the loop
*/
console.log("the index of brebs is: " + list.indexOf("brebs"));


// 7. Repeat (1) and (2) for isEmpty.

/*
  return if the length variable is 0
*/
console.log("is this list empty? " + list.isEmpty());

// 8. Repeat (1) and (2) for size.

/*
  return the length variable
*/
console.log("What is this list's size? " + list.size());


// 9. Repeat (1) and (2) for getHead.

/*
  return the head variable
*/

</script>
</head>
<body>
  See console!
</body>
</html>
